<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Eraskon Inventory Management</title>
  <link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="assets/css/style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.1/dist/tailwind.min.css" rel="stylesheet">
  
  <style>
    /* Global Overrides for White Background and Clean Transitions */
    body {
        background-color: rgb(255, 254, 254) !important;
        transition: background-color 0.3s, color 0.3s;
    }
    .main-content {
        padding: 2rem !important;
        background-color: transparent !important;
    }
    /* Updated styling for chart containers */
    .chart-container {
        padding: 16px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        border: 1px solid #f3f4f6;
        height: 400px; /* Consistent height for most charts */
        min-width: 300px;
    }
    /* New style for the prominent Sales Performance chart */
    .sales-performance-container {
        flex: 1 1 100%; /* Takes up full row */
        max-width: 100%;
        margin-bottom: 20px;
    }
    .chart-row {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
    }
    .chart-row > .chart-container {
        flex: 1 1 calc(50% - 10px); /* Two charts per row for the rest */
    }
    .cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
        margin-bottom: 2rem;
    }
    .card {
        padding: 1.5rem;
        background-color: white;
        border-radius: 12px;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        border: 1px solid #f3f4f6;
    }
    .card h3 {
        font-size: 0.875rem;
        font-weight: 600;
        color: #6b7280;
        margin-bottom: 0.5rem;
        text-transform: uppercase;
    }
    .card p {
        font-size: 2.25rem;
        font-weight: 800;
        color: #1f2937;
    }
  </style>
</head>

<body class="bg-white">
  <script src="components/uiComponents.js"></script>
  <script src="components/spinner.js"></script>
  <script src="components/authGuard.js"></script>
  <script src="components/navbar.js"></script>
  <script src="components/sidebar.js"></script>

  <main id="app" class="main-content">
    
   <div class="mb-6 -mt-2 p-5 bg-white shadow-lg rounded-2xl border border-gray-100">
  <h1 class="flex items-center mb-3 text-2xl sm:text-3xl font-extrabold text-gray-800">
    <i class='bx bxs-bar-chart-square text-blue-600 mr-2 text-3xl'></i> Dashboard Overview
  </h1>
  <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 border-t pt-3 mt-3">
    <div class="flex items-center gap-3">
      <label for="warehouseSelect" class="font-semibold text-gray-700">Select Warehouse:</label>
      <select id="warehouseSelect" v-model="selectedWarehouseId" @change="onWarehouseChange"
        class="p-2.5 border border-gray-300 rounded-xl bg-white text-gray-800 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 shadow-sm transition-all duration-200 min-w-[200px]">
        <option value="">All Warehouses</option>
        <option v-for="w in warehouses" :key="w._id" :value="w._id">{{ w.name }} ({{ w.location }})</option>
      </select>
    </div>
    <div v-if="selectedWarehouse" class="text-sm text-gray-700 p-3 bg-blue-50/70 border-l-4 border-blue-500 rounded-lg shadow-sm">
      <p><i class='bx bxs-map mr-1 text-blue-600'></i><strong>Location:</strong> {{ selectedWarehouse.location }}</p>
      <p class="mt-1"><i class='bx bxs-box mr-1 text-blue-600'></i><strong>Current Stock:</strong> <span class="font-bold text-blue-700">{{ selectedWarehouseTotalStock }} Units</span></p>
    </div>
  </div>
</div>

    <div class="cards">
      <div class="card" v-for="card in cards" :key="card.title">
        <h3>{{ card.title }}</h3>
        <p>{{ card.value }}</p>
      </div>
    </div>

    <div class="chart-row sales-performance-container">
        <div class="chart-container" style="height: 500px; padding-bottom: 5em;"> <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0; font-size: 1.25rem; font-weight: bold;">ü•á Sales Team Performance (Total Revenue)</h4>
                <button @click="downloadChart('salesChart', 'Sales_Team_Performance.png')" class="text-sm text-blue-600 hover:text-blue-800 transition-colors">Download</button>
            </div>
            <canvas id="salesChart"></canvas>
        </div>
    </div>
    <div class="chart-row">
      
      <div class="chart-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <h4 style="margin: 0;">üì¶ Product Stock (By Variant)</h4>
          <button @click="downloadChart('productChart', 'Product_Stock.png')" class="text-sm text-blue-600 hover:text-blue-800 transition-colors">Download</button>
        </div>
        <canvas id="productChart"></canvas>
      </div>
      <div class="chart-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <h4 style="margin: 0;">üí≥ Payment Method Distribution (Completed Sales)</h4>
          <button @click="downloadChart('paymentChart', 'Payment_Method_Pie.png')" class="text-sm text-blue-600 hover:text-blue-800 transition-colors">Download</button>
        </div>
        <canvas id="paymentChart"></canvas>
      </div>
      <div class="chart-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <h4 style="margin: 0;">üìà Product Sales Distribution (Units Sold)</h4>
          <button @click="downloadChart('salesPieChart', 'Product_Sales_Pie.png')" class="text-sm text-blue-600 hover:text-blue-800 transition-colors">Download</button>
        </div>
        <canvas id="salesPieChart"></canvas>
      </div>
      <div class="chart-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <h4 style="margin: 0;">üè≠ Warehouse Stock Distribution (Total Units)</h4>
          <button @click="downloadChart('stockPieChart', 'Warehouse_Stock_Pie.png')" class="text-sm text-blue-600 hover:text-blue-800 transition-colors">Download</button>
        </div>
        <canvas id="stockPieChart"></canvas>
      </div>
      </div>

    <div class="table-section mt-8">
      <h3 class="text-xl font-semibold text-gray-800 mb-3">Product Variant Inventory Table</h3>
      <input type="text" v-model="search" placeholder="Search products..." class="p-3 border border-gray-300 rounded-lg w-full mb-4 focus:ring-blue-500 focus:border-blue-500" />
      <div class="overflow-x-auto bg-white rounded-lg shadow-md">
        <table class="min-w-full divide-y divide-gray-200">
          <thead class="bg-gray-50">
            <tr>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" @click="sort('name')">Name</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" @click="sort('category')">Category</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">SKU</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Barcode</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Batch Tracking</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" @click="sort('stock')">Stock ({{ selectedWarehouseId ? 'Selected WH' : 'Total' }})</th>
              <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total Stock (All WH)</th>
            </tr>
          </thead>
          <tbody class="bg-white divide-y divide-gray-200">
            <tr v-for="product in filteredProducts" :key="product.id">
              <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{{ product.name }}</td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {{ typeof product.category === 'object' ? product.category.name : product.category }}
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{{ product.description }}</td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{{ product.sku }}</td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{{ product.barcode }}</td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{{ product.batchTracking ? 'Yes' : 'No' }}</td>
              <td class="px-6 py-4 whitespace-nowrap text-sm font-bold text-blue-600">
                {{ calculateProductStock(product) }}
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700">{{ product.totalStock ?? product.stock ?? 0 }}</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </main>

  <script src="assets/js/script.js"></script>
  <script src="config.js"></script>
  <script>
    const API_BASE = window.BASE_URL;

    function toggleSidebar() {
      document.body.classList.toggle('collapsed');
    }

    new Vue({
      el: '#app',
      data: {
        warehouses: [],
        selectedWarehouseId: '',
        cards: [
          { title: 'Total Products', value: 0 },
          { title: 'Completed Orders', value: 0 },
          { title: 'Available Stock', value: 0 },
          { title: 'Total Revenue', value: 0 }
        ],
        search: '',
        sortKey: '',
        sortAsc: true,
        selectedMonth: 'all', 
        products: [], // This holds product-variant data
        orders: [],
        salesChart: null,
        productChart: null,
        salesData: {}, 
        stockPieChart: null,
        salesPieChart: null,
        paymentChart: null,
        paymentMethodData: {}
      },
      computed: {
        availableMonths() {
          return Object.keys(this.salesData);
        },
        selectedWarehouse() {
          return this.warehouses.find(w => w._id === this.selectedWarehouseId) || null;
        },
        selectedWarehouseTotalStock() {
          if (!this.selectedWarehouseId) return 0;
          return this.products.reduce((sum, p) => {
            const wh = (p.warehouses || []).find(w => w.warehouse === this.selectedWarehouseId);
            return sum + (wh ? (wh.stock || 0) : 0);
          }, 0);
        },
        filteredProducts() {
          let list = this.products;
          if (this.selectedWarehouseId) {
            // Filter products that have stock in the selected warehouse
            list = list.filter(p =>
              (p.warehouses || []).some(w => w.warehouse === this.selectedWarehouseId && (w.stock || 0) > 0)
            );
          }
          if (this.search) {
            list = list.filter(p =>
              p.name.toLowerCase().includes(this.search.toLowerCase()) ||
              p.sku.toLowerCase().includes(this.search.toLowerCase())
            );
          }
          if (this.sortKey) {
            list.sort((a, b) => {
              let valA = a[this.sortKey];
              let valB = b[this.sortKey];

              if (this.sortKey === 'stock') {
                valA = this.calculateProductStock(a);
                valB = this.calculateProductStock(b);
              } else if (this.sortKey === 'category') {
                 valA = typeof a.category === 'object' ? a.category.name : a.category;
                 valB = typeof b.category === 'object' ? b.category.name : b.category;
              }

              const result = valA > valB ? 1 : -1;
              return this.sortAsc ? result : -result;
            });
          }
          return list;
        }
      },
      methods: {
        calculateProductStock(product) {
            if (this.selectedWarehouseId) {
                const wh = (product.warehouses || []).find(w => w.warehouse === this.selectedWarehouseId);
                return wh ? (wh.stock || 0) : 0;
            }
            return product.totalStock ?? product.stock ?? 0;
        },
        sort(key) {
          if (this.sortKey === key) {
            this.sortAsc = !this.sortAsc;
          } else {
            this.sortKey = key;
            this.sortAsc = true;
          }
        },
        getCSSVar(varName) {
          return getComputedStyle(document.body).getPropertyValue(varName).trim() || 
                 (varName === '--blue-color' ? '#3b82f6' : '#4b5563'); 
        },
        downloadChart(chartId, fileName) {
          const canvas = document.getElementById(chartId);
          const a = document.createElement('a');
          a.href = canvas.toDataURL('image/png');
          a.download = fileName;
          a.click();
        },
        getTextColor() {
          return '#1f2937'; 
        },
        async fetchData() {
          try {
            const token = localStorage.getItem('token');
            // Fetch warehouses
            const warehouseRes = await fetch(`${API_BASE}/warehouse`, {
              headers: { Authorization: `Bearer ${token}` }
            });
            const warehouseData = await warehouseRes.json();
            this.warehouses = Array.isArray(warehouseData) ? warehouseData : (warehouseData.warehouses || []);
            // Fetch products (product-variant)
            const prodRes = await fetch(`${API_BASE}/product-variant`, {
              headers: { Authorization: `Bearer ${token}` }
            });
            const prodData = await prodRes.json();
            this.products = Array.isArray(prodData) ? prodData : (prodData.products || []);
            // Fetch orders
            const orderRes = await fetch(`${API_BASE}/order`, {
              headers: { Authorization: `Bearer ${token}` }
            });
            const orderData = await orderRes.json();
            
            // 1. FILTER ORDERS: Only include 'completed' orders for true purchase records
            const rawOrders = Array.isArray(orderData) ? orderData : (orderData.orders || []);
            this.orders = rawOrders.filter(order => order.status === 'completed');
            
            this.updateCards();
            this.prepareSalesData(); 
            this.preparePaymentMethodData(); 
            this.drawChart();
          } catch (err) {
            alert('Error loading data: ' + err.message + 
    '\\nAPI: ' + API_BASE + 
    '\\nToken: ' + (localStorage.getItem('token') ? 'Present' : 'Missing'));
          }
        },
        prepareSalesData() {
          const revenueByUser = {};
          let orders = this.orders;
          
          if (this.selectedWarehouseId) {
            orders = orders.filter(order =>
              order.warehouse && order.warehouse._id === this.selectedWarehouseId
            );
          }
          
          orders.forEach(order => {
            if (!order.createdBy || !order.createdBy.firstName || !order.createdBy.lastName || !order.total) return;

            const fullName = `${order.createdBy.firstName} ${order.createdBy.lastName}`;
            const total = Number(order.total) || 0;
            
            if (!revenueByUser[fullName]) {
              revenueByUser[fullName] = 0;
            }
            revenueByUser[fullName] += total;
          });
          
          this.salesData = Object.entries(revenueByUser).map(([name, total]) => ({
            name,
            total
          }));
          
          this.salesData.sort((a, b) => b.total - a.total);
        },
        preparePaymentMethodData() {
            const paymentStats = {};
            let paidOrders = this.orders.filter(order => 
                order.paymentConfirmed === true && order.paymentStatus === 'paid'
            );

            if (this.selectedWarehouseId) {
                paidOrders = paidOrders.filter(order => order.warehouse && order.warehouse._id === this.selectedWarehouseId);
            }

            paidOrders.forEach(order => {
                const method = order.paymentMethod ? order.paymentMethod.toLowerCase() : 'other';
                paymentStats[method] = (paymentStats[method] || 0) + 1;
            });
            this.paymentMethodData = paymentStats;
        },
        drawChart() {
          const barColor = '#4A90E2'; 
          const textColor = this.getTextColor(); 
          const tooltipBgColor = '#1f2937'; 
          const lightTextColor = 'white';   

          if (this.salesChart) this.salesChart.destroy();
          if (this.productChart) this.productChart.destroy();
          if (this.salesPieChart) this.salesPieChart.destroy();
          if (this.stockPieChart) this.stockPieChart.destroy();
          if (this.paymentChart) this.paymentChart.destroy();

          const ctxSales = document.getElementById("salesChart").getContext("2d");
          const ctxProduct = document.getElementById("productChart").getContext("2d");
          const ctxSalesPie = document.getElementById("salesPieChart").getContext("2d");
          const ctxStockPie = document.getElementById("stockPieChart").getContext("2d");
          const ctxPayment = document.getElementById("paymentChart").getContext("2d");

          // SALES CHART: Sales Team Performance (Bar Chart)
          this.salesChart = new Chart(ctxSales, {
            type: "bar",
            data: {
              labels: this.salesData.map(d => d.name),
              datasets: [
                {
                  label: "Total Revenue (‚Ç¶)",
                  data: this.salesData.map(d => d.total),
                  backgroundColor: barColor,
                  borderRadius: 6,
                  borderSkipped: false
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              indexAxis: 'y', // Horizontal bar chart
              layout: {
                  padding: {
                      left: 10 // Added slight left padding for Y-axis names
                  }
              },
              plugins: {
                legend: { display: false }, 
                tooltip: {
                  backgroundColor: tooltipBgColor, 
                  titleColor: lightTextColor,      
                  bodyColor: lightTextColor,       
                  callbacks: {
                      label: function(context) {
                          let label = context.dataset.label || '';
                          if (label) {
                              label += ': ';
                          }
                          if (context.parsed.x !== null) { 
                              label += '‚Ç¶' + context.parsed.x.toLocaleString('en-NG', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                          }
                          return label;
                      }
                  }
                },
                datalabels: {
                  color: textColor,
                  anchor: 'end',
                  align: 'end', 
                  font: { size: 10, weight: 'bold' },
                  formatter: (value) => `‚Ç¶${Math.round(value).toLocaleString()}` 
                }
              },
              scales: {
                x: { 
                  beginAtZero: true,
                  title: {
                      display: true,
                      text: 'Revenue (‚Ç¶)',
                      color: textColor
                  },
                  ticks: { 
                      color: textColor,
                      callback: function(value) {
                          return '‚Ç¶' + value.toLocaleString(); 
                      } 
                  },
                  grid: { color: '#e0e0e020' } 
                },
                y: { 
                  // Fix for overlap: Increased min rotation and font size adjustment
                  ticks: { 
                      color: textColor,
                      font: {
                          size: 10 // Smaller font for Y-axis labels to prevent overlap
                      }
                  },
                  grid: { display: false } 
                }
              }
            },
            plugins: [ChartDataLabels]
          });
          // END SALES CHART

          // CHART: Payment Method Distribution
          this.paymentChart = new Chart(ctxPayment, {
            type: "pie",
            data: {
              labels: Object.keys(this.paymentMethodData).map(m => m.charAt(0).toUpperCase() + m.slice(1)),
              datasets: [{
                data: Object.values(this.paymentMethodData),
                backgroundColor: Object.keys(this.paymentMethodData).map((_, i) =>
                  `hsl(${i * 360 / Object.keys(this.paymentMethodData).length}, 70%, 50%)`
                )
              }]
            },
            options: {
              responsive: true,
              plugins: {
                legend: { labels: { color: this.getTextColor() } },
                tooltip: {
                    backgroundColor: tooltipBgColor, 
                    titleColor: lightTextColor,      
                    bodyColor: lightTextColor,       
                    callbacks: {
                        label: function(context) {
                            let label = context.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed !== null) {
                                label += context.parsed + ' orders';
                            }
                            return label;
                        }
                    }
                },
                datalabels: {
                  color: 'white',
                  font: { weight: 'bold' },
                  formatter: (value, context) => {
                      const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                      const percentage = ((value / total) * 100).toFixed(1) + '%';
                      return percentage;
                  }
                }
              }
            },
            plugins: [ChartDataLabels]
          });
          // END PAYMENT METHOD DISTRIBUTION

          // PRODUCT STOCK CHART (Bar Chart) - Uses product-variant data
          const chartProducts = this.products.map(p => ({
              name: p.name,
              stock: this.calculateProductStock(p)
          })).filter(p => p.stock > 0); 

          this.productChart = new Chart(ctxProduct, {
            type: "bar",
            data: {
              labels: chartProducts.map(p => p.name),
              datasets: [{
                label: "Stock Level (Units)",
                data: chartProducts.map(p => p.stock),
                backgroundColor: barColor,
                borderRadius: 6,
                borderSkipped: false
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false }, 
                tooltip: {
                  backgroundColor: tooltipBgColor, 
                  titleColor: lightTextColor,      
                  bodyColor: lightTextColor       
                },
                datalabels: {
                  color: textColor,
                  anchor: 'end',
                  align: 'top',
                  font: { weight: 'bold' },
                  formatter: Math.round
                }
              },
              scales: {
                x: {
                  ticks: { color: textColor },
                  grid: { display: false }
                },
                y: {
                  beginAtZero: true,
                  ticks: { color: textColor },
                  grid: { color: '#e0e0e020' } 
                }
              }
            },
            plugins: [ChartDataLabels]
          });
          // END PRODUCT STOCK CHART

          // Product Sales Pie Chart
          this.salesPieChart = new Chart(ctxSalesPie, {
            type: "pie",
            data: {
              labels: this.getProductSalesData().map(s => s.name),
              datasets: [{
                data: this.getProductSalesData().map(s => s.count),
                backgroundColor: this.getProductSalesData().map((_, i) =>
                  `hsl(${i * 360 / this.getProductSalesData().length}, 70%, 60%)`
                )
              }]
            },
            options: {
              responsive: true,
              plugins: {
                legend: { labels: { color: this.getTextColor() } },
                tooltip: {
                    backgroundColor: tooltipBgColor, 
                    titleColor: lightTextColor,      
                    bodyColor: lightTextColor,       
                },
                datalabels: {
                  color: 'white',
                  font: { weight: 'bold' },
                  formatter: (value, context) => {
                      const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                      const percentage = ((value / total) * 100).toFixed(1) + '%';
                      return percentage;
                  }
                }
              }
            },
            plugins: [ChartDataLabels]
          });

          // Warehouse Stock Pie Chart
          this.stockPieChart = new Chart(ctxStockPie, {
            type: "pie",
            data: {
              labels: this.getWarehouseStockData().map(s => s.name),
              datasets: [{
                data: this.getWarehouseStockData().map(s => s.stock),
                backgroundColor: this.getWarehouseStockData().map((_, i) =>
                  `hsl(${i * 360 / this.getWarehouseStockData().length}, 70%, 60%)`
                )
              }]
            },
            options: {
              responsive: true,
              plugins: {
                legend: { labels: { color: this.getTextColor() } },
                tooltip: {
                    backgroundColor: tooltipBgColor, 
                    titleColor: lightTextColor,      
                    bodyColor: lightTextColor,       
                },
                datalabels: {
                  color: 'white',
                  font: { weight: 'bold' },
                  formatter: (value, context) => {
                      const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                      const percentage = ((value / total) * 100).toFixed(1) + '%';
                      return percentage;
                  }
                }
              }
            },
            plugins: [ChartDataLabels]
          });
        },
        updateCards() {
          let totalProducts = new Set();
          let totalAmount = 0;
          let orderCount = this.orders.length; 
          let availableStock = 0; 

          this.orders.forEach(order => {
              let orderAmount = 0;
              if (order.items && Array.isArray(order.items)) {
                  order.items.forEach(item => {
                      totalProducts.add(item.productVariantId || item.product || item.sku || item.name);
                      orderAmount += (Number(item.price) || 0) * (Number(item.quantity) || 1);
                  });
              }
              totalAmount += orderAmount || Number(order.total) || 0; 
          });

          if (this.selectedWarehouseId) {
            
            let whProductSet = new Set();
            let whTotalAmount = 0;
            let whOrderCount = 0;

            this.orders.forEach(order => {
              if (order.warehouse && order.warehouse._id === this.selectedWarehouseId) {
                
                let orderAmount = 0;
                
                if (order.items && Array.isArray(order.items)) {
                  order.items.forEach(item => {
                    const uniqueId = item.productVariantId || item.product || item.sku || item.name;
                    if (uniqueId) {
                        whProductSet.add(uniqueId);
                    }
                    orderAmount += (Number(item.price) || 0) * (Number(item.quantity) || 1);
                  });
                }
                
                whOrderCount += 1;
                whTotalAmount += orderAmount || Number(order.total) || 0;
              }
            });

            availableStock = this.selectedWarehouseTotalStock;

            this.cards = [
              { title: 'Total Products (WH)', value: whProductSet.size },
              { title: 'Completed Orders (WH)', value: whOrderCount }, 
              { title: 'Available Stock (WH)', value: availableStock },
              { title: 'Total Revenue (WH)', value: `‚Ç¶${whTotalAmount.toLocaleString('en-NG', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` } 
            ];
          } else {
            // All warehouses (default)
            availableStock = this.products.reduce((sum, p) => 
                sum + (p.warehouses || []).reduce((whSum, wh) => whSum + (wh.stock || 0), 0)
            , 0);

            this.cards = [
              { title: 'Total Products', value: totalProducts.size },
              { title: 'Completed Orders', value: orderCount }, 
              { title: 'Available Stock', value: availableStock },
              { title: 'Total Revenue', value: `‚Ç¶${totalAmount.toLocaleString('en-NG', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}` } 
            ];
          }
        },
        onWarehouseChange() {
          this.prepareSalesData();
          this.preparePaymentMethodData(); 
          this.drawChart();
          this.updateCards();
        },
        getProductSalesData() {
          const stats = {};
          this.orders.forEach(order => {
            if (!order.items) return;
            if (!this.selectedWarehouseId || (order.warehouse && order.warehouse._id === this.selectedWarehouseId)) {
                order.items.forEach(item => {
                    const key = item.name || item.productVariantName || item.product || item.sku;
                    if (!stats[key]) stats[key] = { name: key, count: 0 };
                    stats[key].count += Number(item.qty) || Number(item.quantity) || 1;
                });
            }
          });
          return Object.values(stats);
        },
        getWarehouseStockData() {
          const warehouseStockMap = {};
          this.warehouses.forEach(w => {
            warehouseStockMap[w._id] = { name: w.name, stock: 0 };
          });
          this.products.forEach(product => {
            (product.warehouses || []).forEach(whData => {
              const warehouseId = whData.warehouse;
              const stock = whData.stock || 0;
              if (warehouseStockMap[warehouseId]) {
                warehouseStockMap[warehouseId].stock += stock;
              } 
            });
          });
          return Object.values(warehouseStockMap)
                       .filter(data => data.stock > 0);
        }
      },
      mounted() {
        this.fetchData();
        const observer = new MutationObserver(() => this.drawChart());
        observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
      }
    });
  </script>
</body>

</html>